#version 460
#extension GL_EXT_mesh_shader : require
#include "voxel.glsl"

struct vertex_t {
    vec3 position;
    vec2 texel_coord;
};

vertex_t cube_vertices[NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_VERTICES] = {
    // +X
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(0.0, 0.0)),
    // -X
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(-0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(-0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(1.0, 1.0)),
    // +Y
    vertex_t(vec3(0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 1.0)),
    // -Y
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, -0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, -0.0, -0.0), vec2(0.0, 1.0)),
    // +Z
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 0.0, -0.0), vec2(0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, 0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(0.0, 1.0, 0.0), vec2(1.0, 0.0)),
    // -Z
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 1.0))
};

uvec3 cube_triangles[NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_TRIANGLES] = {
    // +X
    uvec3(0, 1, 2),
    uvec3(0, 2, 3),
    // -X
    uvec3(4, 5, 6),
    uvec3(4, 6, 7),
    // +Y
    uvec3(8, 9, 10),
    uvec3(8, 10, 11),
    // -Y
    uvec3(12, 13, 14),
    uvec3(12, 14, 15),
    // +Z
    uvec3(16, 17, 18),
    uvec3(16, 18, 19),
    // -Z
    uvec3(20, 21, 22),
    uvec3(20, 22, 23)
};

// Hope and pray
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(triangles, max_vertices = 64, max_primitives = 126) out;

layout(push_constant, std430) uniform voxel_push_constants_t {
    mat4 view_projection;
};

layout(set = 0, binding = 0) uniform usampler3D voxel_sampler;

layout(set = 0, binding = 1) uniform voxel_uniform_t {
    vec3 region_position;
};

layout(location = 0) out vertex_out_t {
    vec3 vertex_texel_coord;
} mesh_vertices[];

float get_layer_index(uint face_index, uint voxel_type) {
    switch (voxel_type) {
        case VOXEL_TYPE_GRASS: switch (face_index) {
            default: return 3.0;
            case VOXEL_PY_FACE_INDEX: return 0.0;
            case VOXEL_NY_FACE_INDEX: return 2.0;
        }
        case VOXEL_TYPE_STONE: return 1.0;
        case VOXEL_TYPE_DIRT: return 2.0;
    }
    return 0.0;
}

void main() {
    // TODO: Implement correctly maybe??
    SetMeshOutputsEXT(NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_VERTICES, NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_TRIANGLES);

    vec3 voxel_position = vec3(gl_GlobalInvocationID);

    uint vertex_index = gl_LocalInvocationIndex * NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_VERTICES;

    for (uint i = 0; i < NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_VERTICES; i++) {
        vertex_t vertex = cube_vertices[i];

        gl_MeshVerticesEXT[vertex_index + i].gl_Position = view_projection * 1.0 * vec4(region_position + voxel_position + vertex.position, 1.0);
        mesh_vertices[vertex_index + i].vertex_texel_coord = vec3(vertex.texel_coord, 0.0);
    }
    
    uint triangle_index = gl_LocalInvocationIndex * NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_TRIANGLES;

    for (uint i = 0; i < NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_TRIANGLES; i++) {
        gl_PrimitiveTriangleIndicesEXT[triangle_index + i] = cube_triangles[i];
    }
}