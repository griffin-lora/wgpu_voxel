#version 460
#extension GL_EXT_mesh_shader : require
#include "voxel.glsl"

struct vertex_t {
    vec3 position;
    vec2 texel_coord;
};

vertex_t cube_vertices[NUM_CUBE_VOXEL_VERTICES] = {
    // +X
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(0.0, 0.0)),
    // -X
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(-0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(-0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(-0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(1.0, 1.0)),
    // +Y
    vertex_t(vec3(0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 1.0)),
    // -Y
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, -0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, -0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, -0.0, -0.0), vec2(0.0, 1.0)),
    // +Z
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 0.0, -0.0), vec2(0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, 0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, 0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(0.0, 1.0, 0.0), vec2(1.0, 0.0)),
    // -Z
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 1.0))
};

// Hope and pray
layout(local_size_x = 2, local_size_y = 2, local_size_z = 2) in;

layout(triangles, max_vertices = 256, max_primitives = 126) out;

layout(push_constant, std430) uniform voxel_push_constants_t {
    mat4 view_projection;
};

layout(set = 0, binding = 1, r32ui) readonly uniform uimage3D voxel_image;

layout(set = 0, binding = 1) uniform voxel_uniform_t {
    vec3 region_position;
};

layout(location = 0) out vertex_out_t {
    vec2 texel_coord;
} vertex_out[];

void main() {
    // TODO: Implement correctly maybe??
    SetMeshOutputsEXT(256, 126);

    vec3 offset = gl_GlobalInvocationID;

    uint vertex_index = gl_LocalInvocationIndex * 3;

    gl_MeshVerticesEXT[vertex_index].gl_Position = view_projection * vec4(cube_vertices[0].position + offset, 1.0);
    gl_MeshVerticesEXT[vertex_index + 1].gl_Position = view_projection * vec4(cube_vertices[1].position + offset, 1.0);
    gl_MeshVerticesEXT[vertex_index + 2].gl_Position = view_projection * vec4(cube_vertices[2].position + offset, 1.0);

    vertex_out[vertex_index].texel_coord = cube_vertices[0].texel_coord;
    vertex_out[vertex_index + 1].texel_coord = cube_vertices[1].texel_coord;
    vertex_out[vertex_index + 2].texel_coord = cube_vertices[2].texel_coord;

    gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationIndex] = uvec3(vertex_index, vertex_index + 1, vertex_index + 2);
}