#version 460
#extension GL_EXT_mesh_shader : require
#include "voxel.glsl"

struct vertex_t {
    vec3 position;
    vec2 texel_coord;
};

vertex_t cube_vertices[NUM_CUBE_VOXEL_VERTICES] = {
    // +X
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(0.0, 0.0)),
    // -X
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(-0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(-0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(-0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(1.0, 1.0)),
    // +Y
    vertex_t(vec3(0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 1.0)),
    // -Y
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, -0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, -0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, -0.0, -0.0), vec2(0.0, 1.0)),
    // +Z
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 0.0, -0.0), vec2(0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, 0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, 0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(0.0, 1.0, 0.0), vec2(1.0, 0.0)),
    // -Z
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 1.0))
};

// Hope and pray
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(triangles, max_vertices = 64, max_primitives = 126) out;

layout(push_constant, std430) uniform voxel_push_constants_t {
    mat4 view_projection;
};

layout(set = 0, binding = 0, r32ui) readonly uniform uimage3D voxel_image;

layout(set = 0, binding = 1) uniform voxel_uniform_t {
    vec3 region_position;
};

layout(location = 0) out vertex_out_t {
    vec3 vertex_texel_coord;
} mesh_vertices[];

float get_layer_index(uint face_index, uint voxel_type) {
    switch (voxel_type) {
        case VOXEL_TYPE_GRASS: switch (face_index) {
            default: return 3.0;
            case VOXEL_PY_FACE_INDEX: return 0.0;
            case VOXEL_NY_FACE_INDEX: return 2.0;
        }
        case VOXEL_TYPE_STONE: return 1.0;
        case VOXEL_TYPE_DIRT: return 2.0;
    }
    return 0.0;
}

void add_face_vertices(uint triangle_index, vec3 voxel_position, uint face_index, uint voxel_type, float face_visible) {
    uint vertex_index = triangle_index * 3;
    float layer_index = get_layer_index(face_index, voxel_type);

    for (int i = 0; i < NUM_CUBE_VOXEL_FACE_VERTICES; i++) {
        vec3 vertex_position = cube_vertices[NUM_CUBE_VOXEL_FACE_VERTICES * face_index + i].position;
        vec2 vertex_texel_coord = cube_vertices[NUM_CUBE_VOXEL_FACE_VERTICES * face_index + i].texel_coord;

        gl_MeshVerticesEXT[vertex_index + i].gl_Position = view_projection * face_visible * vec4(region_position + voxel_position + vertex_position, 1.0);
        mesh_vertices[vertex_index + i].vertex_texel_coord = vec3(vertex_texel_coord, layer_index);
    }
    
    gl_PrimitiveTriangleIndicesEXT[triangle_index] = uvec3(vertex_index, vertex_index + 1, vertex_index + 2);
    gl_PrimitiveTriangleIndicesEXT[triangle_index + 1] = uvec3(vertex_index + 3, vertex_index + 4, vertex_index + 5);
}

void main() {
    // TODO: Implement correctly maybe??
    SetMeshOutputsEXT(64, 126);

    uint voxel_type = imageLoad(voxel_image, ivec3(gl_GlobalInvocationID)).x;

    uint triangle_index = gl_LocalInvocationIndex * 2;
    vec3 voxel_position = vec3(gl_GlobalInvocationID);
    
    if (voxel_type == 0) {
        add_face_vertices(triangle_index, voxel_position, VOXEL_PX_FACE_INDEX, voxel_type, 0.0);
        add_face_vertices(triangle_index + 2, voxel_position, VOXEL_NX_FACE_INDEX, voxel_type, 0.0);
        add_face_vertices(triangle_index + 4, voxel_position, VOXEL_PY_FACE_INDEX, voxel_type, 0.0);
        add_face_vertices(triangle_index + 6, voxel_position, VOXEL_NY_FACE_INDEX, voxel_type, 0.0);
        add_face_vertices(triangle_index + 8, voxel_position, VOXEL_PZ_FACE_INDEX, voxel_type, 0.0);
        add_face_vertices(triangle_index + 10, voxel_position, VOXEL_NZ_FACE_INDEX, voxel_type, 0.0);
        return;
    }

    float px_visible = float(imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) + ivec3(1, 0, 0)).x == 0);
    float nx_visible = float(imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) - ivec3(1, 0, 0)).x == 0);
    float py_visible = float(imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) + ivec3(0, 1, 0)).x == 0);
    float ny_visible = float(imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) - ivec3(0, 1, 0)).x == 0);
    float pz_visible = float(imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) + ivec3(0, 0, 1)).x == 0);
    float nz_visible = float(imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) - ivec3(0, 0, 1)).x == 0);

    add_face_vertices(triangle_index, voxel_position, VOXEL_PX_FACE_INDEX, voxel_type, px_visible);
    add_face_vertices(triangle_index + 2, voxel_position, VOXEL_NX_FACE_INDEX, voxel_type, nx_visible);
    add_face_vertices(triangle_index + 4, voxel_position, VOXEL_PY_FACE_INDEX, voxel_type, py_visible);
    add_face_vertices(triangle_index + 6, voxel_position, VOXEL_NY_FACE_INDEX, voxel_type, ny_visible);
    add_face_vertices(triangle_index + 8, voxel_position, VOXEL_PZ_FACE_INDEX, voxel_type, pz_visible);
    add_face_vertices(triangle_index + 10, voxel_position, VOXEL_NZ_FACE_INDEX, voxel_type, nz_visible);
}