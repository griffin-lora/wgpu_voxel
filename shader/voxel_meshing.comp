#version 460

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

struct voxel_vertex_t {
    vec3 position;
    vec2 texel_coord;
};

#define NUM_CUBE_VOXEL_VERTICES 36u
#define NUM_CUBE_VOXEL_FACE_VERTICES 6u

voxel_vertex_t cube_voxel_vertices[NUM_CUBE_VOXEL_VERTICES] = {
    // +X
    voxel_vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 0.0, -0.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(1.0, 0.0, -1.0), vec2(-0.0, 1.0)),
    voxel_vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 0.0, -1.0), vec2(-0.0, 1.0)),
    voxel_vertex_t(vec3(1.0, 1.0, -1.0), vec2(0.0, 0.0)),
    // -X
    voxel_vertex_t(vec3(0.0, 0.0, -0.0), vec2(-0.0, 1.0)),
    voxel_vertex_t(vec3(-0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(-0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    voxel_vertex_t(vec3(0.0, 0.0, -0.0), vec2(-0.0, 1.0)),
    voxel_vertex_t(vec3(-0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    voxel_vertex_t(vec3(0.0, 0.0, -1.0), vec2(1.0, 1.0)),
    // +Y
    voxel_vertex_t(vec3(0.0, 1.0, -0.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(1.0, 1.0, -0.0), vec2(0.0, 1.0)),
    voxel_vertex_t(vec3(1.0, 1.0, -1.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(0.0, 1.0, -0.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(1.0, 1.0, -1.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    // -Y
    voxel_vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 0.0)),
    voxel_vertex_t(vec3(1.0, -0.0, -0.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(1.0, -0.0, -0.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(0.0, -0.0, -0.0), vec2(0.0, 1.0)),
    // +Z
    voxel_vertex_t(vec3(0.0, 0.0, -0.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 0.0, -0.0), vec2(1.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 1.0, 0.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(0.0, 0.0, -0.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 1.0, 0.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(0.0, 1.0, 0.0), vec2(0.0, 1.0)),
    // -Z
    voxel_vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 0.0)),
    voxel_vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 1.0)),
    voxel_vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 1.0))
};

layout(set = 0, binding = 0, r32ui) readonly uniform uimage3D voxel_image;

layout(set = 0, binding = 1) writeonly buffer num_vertices_out_t {
    uint num_vertices;
};

layout(set = 0, binding = 2) writeonly buffer vertices_out_t {
    voxel_vertex_t vertices[];
};

void add_face_vertices(vec3 voxel_position, uint vertex_index, uint face_index) {
    for (int i = 0; i < NUM_CUBE_VOXEL_FACE_VERTICES; i++) {
        voxel_vertex_t vertex = cube_voxel_vertices[NUM_CUBE_VOXEL_FACE_VERTICES * face_index + i];
        vertices[vertex_index + i] = voxel_vertex_t(vertex.position + voxel_position, vertex.texel_coord);
    }
}

void main() {
    uint voxel_type = imageLoad(voxel_image, ivec3(gl_GlobalInvocationID)).x;
    
    if (voxel_type == 0) {
        return;
    }

    bool px_visible = imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) + ivec3(1, 0, 0)).x == 0;
    bool nx_visible = imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) - ivec3(1, 0, 0)).x == 0;
    bool py_visible = imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) + ivec3(0, 1, 0)).x == 0;
    bool ny_visible = imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) - ivec3(0, 1, 0)).x == 0;
    bool pz_visible = imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) + ivec3(0, 0, 1)).x == 0;
    bool nz_visible = imageLoad(voxel_image, ivec3(gl_GlobalInvocationID) - ivec3(0, 0, 1)).x == 0;

    vec3 voxel_position = vec3(gl_GlobalInvocationID);

    uint num_voxel_vertices = NUM_CUBE_VOXEL_FACE_VERTICES * (uint(px_visible) + uint(nx_visible) + uint(py_visible) + uint(ny_visible) + uint(pz_visible) + uint(nz_visible));
    uint vertex_index = atomicAdd(num_vertices, num_voxel_vertices);

    if (px_visible) {
        add_face_vertices(voxel_position, vertex_index, 0);
        vertex_index += NUM_CUBE_VOXEL_FACE_VERTICES;
    }
    if (nx_visible) {
        add_face_vertices(voxel_position, vertex_index, 1);
        vertex_index += NUM_CUBE_VOXEL_FACE_VERTICES;
    }
    if (py_visible) {
        add_face_vertices(voxel_position, vertex_index, 2);
        vertex_index += NUM_CUBE_VOXEL_FACE_VERTICES;
    }
    if (ny_visible) {
        add_face_vertices(voxel_position, vertex_index, 3);
        vertex_index += NUM_CUBE_VOXEL_FACE_VERTICES;
    }
    if (pz_visible) {
        add_face_vertices(voxel_position, vertex_index, 4);
        vertex_index += NUM_CUBE_VOXEL_FACE_VERTICES;
    }
    if (nz_visible) {
        add_face_vertices(voxel_position, vertex_index, 5);
    }
}