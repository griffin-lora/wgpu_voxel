#version 460
#extension GL_EXT_mesh_shader : require
#include "voxel.glsl"

struct vertex_t {
    vec3 position;
    vec2 texel_coord;
};

vertex_t cube_vertices[NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_VERTICES] = {
    // +X
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(0.0, 0.0)),
    // -X
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(-0.0, 1.0)),
    vertex_t(vec3(-0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(-0.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(1.0, 1.0)),
    // +Y
    vertex_t(vec3(0.0, 1.0, -0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -0.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 1.0)),
    // -Y
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, -0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, -0.0, -0.0), vec2(0.0, 1.0)),
    // +Z
    vertex_t(vec3(0.0, 0.0, -0.0), vec2(1.0, 1.0)),
    vertex_t(vec3(1.0, 0.0, -0.0), vec2(0.0, 1.0)),
    vertex_t(vec3(1.0, 1.0, 0.0), vec2(0.0, 0.0)),
    vertex_t(vec3(0.0, 1.0, 0.0), vec2(1.0, 0.0)),
    // -Z
    vertex_t(vec3(0.0, 1.0, -1.0), vec2(0.0, 0.0)),
    vertex_t(vec3(1.0, 1.0, -1.0), vec2(1.0, 0.0)),
    vertex_t(vec3(1.0, 0.0, -1.0), vec2(1.0, 1.0)),
    vertex_t(vec3(0.0, 0.0, -1.0), vec2(0.0, 1.0))
};

uvec3 cube_triangles[NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_TRIANGLES] = {
    // +X
    uvec3(0, 1, 2),
    uvec3(0, 2, 3),
    // -X
    uvec3(4, 5, 6),
    uvec3(4, 6, 7),
    // +Y
    uvec3(8, 9, 10),
    uvec3(8, 10, 11),
    // -Y
    uvec3(12, 13, 14),
    uvec3(12, 14, 15),
    // +Z
    uvec3(16, 17, 18),
    uvec3(16, 18, 19),
    // -Z
    uvec3(20, 21, 22),
    uvec3(20, 22, 23)
};

layout(local_size_x = 2, local_size_y = 2, local_size_z = 2) in;

layout(triangles, max_vertices = 256, max_primitives = 126) out;

layout(push_constant, std430) uniform push_constants_t {
    mat4 view_projection;
};

layout(set = 0, binding = 0) uniform usampler3D voxel_sampler;

layout(set = 0, binding = 1) uniform uniform_t {
    vec3 region_position;
};

taskPayloadSharedEXT uvec3 task_position;

layout(location = 0) out out_vertex_t {
    vec3 vertex_texel_coord;
} out_vertices[];

float get_layer_index(uint face_index, uint voxel_type) {
    switch (voxel_type) {
        case VOXEL_TYPE_GRASS: switch (face_index) {
            default: return 3.0;
            case VOXEL_PY_FACE_INDEX: return 0.0;
            case VOXEL_NY_FACE_INDEX: return 2.0;
        }
        case VOXEL_TYPE_STONE: return 1.0;
        case VOXEL_TYPE_DIRT: return 2.0;
    }
    return 0.0;
}

void main() {
    SetMeshOutputsEXT(
        gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_VERTICES,
        gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_TRIANGLES
    );

    uvec3 voxel_position = task_position + gl_GlobalInvocationID;

    ivec3 voxel_sampler_position = ivec3(voxel_position);

    uint voxel_type = texelFetch(voxel_sampler, voxel_sampler_position, 0).x;
    float voxel_scalar = float(voxel_type != 0);

    float voxel_scalars[NUM_CUBE_VOXEL_FACES];

    voxel_scalars[VOXEL_PX_FACE_INDEX] = voxel_scalar * float(texelFetch(voxel_sampler, voxel_sampler_position + ivec3(1, 0, 0), 0).x == 0);
    voxel_scalars[VOXEL_NX_FACE_INDEX] = voxel_scalar * float(texelFetch(voxel_sampler, voxel_sampler_position - ivec3(1, 0, 0), 0).x == 0);
    voxel_scalars[VOXEL_PY_FACE_INDEX] = voxel_scalar * float(texelFetch(voxel_sampler, voxel_sampler_position + ivec3(0, 1, 0), 0).x == 0);
    voxel_scalars[VOXEL_NY_FACE_INDEX] = voxel_scalar * float(texelFetch(voxel_sampler, voxel_sampler_position - ivec3(0, 1, 0), 0).x == 0);
    voxel_scalars[VOXEL_PZ_FACE_INDEX] = voxel_scalar * float(texelFetch(voxel_sampler, voxel_sampler_position + ivec3(0, 0, 1), 0).x == 0);
    voxel_scalars[VOXEL_NZ_FACE_INDEX] = voxel_scalar * float(texelFetch(voxel_sampler, voxel_sampler_position - ivec3(0, 0, 1), 0).x == 0);
    
    vec3 voxel_vertex_position = vec3(voxel_position);

    uint vertex_index = gl_LocalInvocationIndex * NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_VERTICES;

    for (uint face_index = 0; face_index < NUM_CUBE_VOXEL_FACES; face_index++) {
        for (uint i = 0; i < NUM_CUBE_VOXEL_FACE_VERTICES; i++) {
            uint cube_vertex_index = (face_index * NUM_CUBE_VOXEL_FACE_VERTICES) + i;

            vertex_t vertex = cube_vertices[cube_vertex_index];

            gl_MeshVerticesEXT[vertex_index + cube_vertex_index].gl_Position = view_projection * voxel_scalars[face_index] * vec4(region_position + voxel_vertex_position + vertex.position, 1.0);
            out_vertices[vertex_index + cube_vertex_index].vertex_texel_coord = vec3(vertex.texel_coord, get_layer_index(face_index, voxel_type));
        }
    }
    
    uint triangle_index = gl_LocalInvocationIndex * NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_TRIANGLES;

    for (uint i = 0; i < NUM_CUBE_VOXEL_FACES * NUM_CUBE_VOXEL_FACE_TRIANGLES; i++) {
        gl_PrimitiveTriangleIndicesEXT[triangle_index + i] = uvec3(vertex_index) + cube_triangles[i];
    }
}